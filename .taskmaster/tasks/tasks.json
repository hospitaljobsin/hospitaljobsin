{
	"master": {
		"tasks": [
			{
				"id": 59,
				"title": "Backend: Implement `verificationStatus` Field on OrganizationType",
				"description": "Add a `verificationStatus` field to the `OrganizationType` in the Strawberry GraphQL schema. This field will resolve to a `VerificationStatusEnum` with one of four values: `VERIFIED`, `PENDING`, `REJECTED`, or `NOT_REQUESTED` based on the organization's verification data.",
				"status": "done",
				"dependencies": [],
				"priority": "high",
				"details": "Using Strawberry GraphQL, define a new `VerificationStatusEnum` following the existing pattern in the codebase (e.g., `InviteStatusTypeEnum`, `BusinessProofTypeEnum`). This will involve creating a Python `enum.Enum` and registering it. Then, modify the `OrganizationType` by adding a new resolver method decorated with `@strawberry.field` for `verificationStatus`. This resolver will return the `VerificationStatusEnum`. The logic for the resolver is as follows:\n1. Check if the `organization.verifiedAt` field has a value. If yes, return `VERIFIED`.\n2. If not, query the `OrganizationVerificationRequest` collection for the most recent request associated with the organization ID.\n3. If a request exists, check its status. Return `PENDING` or `REJECTED` accordingly.\n4. If no request exists, return `NOT_REQUESTED`.\nEnsure the database query is indexed and efficient.",
				"testStrategy": "Unit test the resolver by mocking the organization and verification request data for all four possible enum outcomes (`VERIFIED`, `PENDING`, `REJECTED`, `NOT_REQUESTED`). For integration testing, use a Relay GraphQL client against a development server to verify the enum status for organizations in different states, ensuring the tests are consistent with existing Relay patterns and tools in the codebase.",
				"subtasks": [
					{
						"id": 1,
						"title": "",
						"description": "Define the `VerificationStatusEnum` using Python's `enum.Enum` and register it with Strawberry, following the pattern of existing enums like `InviteStatusTypeEnum`.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 2,
						"title": "",
						"description": "Add the `verificationStatus` field to the `OrganizationType` Strawberry type using the `@strawberry.field` decorator.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 3,
						"title": "",
						"description": "Implement the resolver logic for the `verificationStatus` field within the `OrganizationType`. The logic should correctly query for `verifiedAt` and `OrganizationVerificationRequest` data.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 4,
						"title": "",
						"description": "Write unit tests for the `verificationStatus` resolver, covering all four enum cases.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 5,
						"title": "",
						"description": "Perform integration testing using a Relay GraphQL client to verify the `verificationStatus` field against a live development server.",
						"status": "done",
						"dependencies": [4],
						"details": "Test with organizations in various states to confirm that `VERIFIED`, `PENDING`, `REJECTED`, and `NOT_REQUESTED` are returned correctly. Ensure testing follows existing Relay patterns and tools.",
						"testStrategy": ""
					}
				]
			},
			{
				"id": 60,
				"title": "Frontend: Create Main Verification Status Controller Component",
				"description": "Create the main parent component that uses a Relay fragment to access the organization's verification status and conditionally renders the appropriate UI view based on the result.",
				"status": "done",
				"dependencies": [59],
				"priority": "high",
				"details": "Create a React component named `OrganizationVerificationStatusController`. This component will accept a fragment reference from a parent component and use Relay's `useFragment` hook to read the `verificationStatus` for the current organization. The implementation should follow standard Relay patterns for fragment composition, defining a GraphQL fragment for its data requirements. Based on the `verificationStatus` read from the fragment, it will act as a router to render one of the child components: `AlreadyVerified`, `PendingVerificationView`, `RejectedVerificationView`, or `RequestVerificationForm`.",
				"testStrategy": "Use Storybook or React Testing Library to test this component. Mock the Relay environment and the data passed to the `useFragment` hook to simulate each status ('verified', 'pending', 'rejected', 'not_requested'). Verify that the correct child component is rendered for each case. Test that the component correctly reads the data from the provided fragment.",
				"subtasks": [
					{
						"id": 1,
						"title": "",
						"description": "Define the Relay GraphQL fragment to specify the `organization.verificationStatus` data requirement.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 2,
						"title": "",
						"description": "Set up the `OrganizationVerificationStatusController` component to accept a fragment reference prop.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 3,
						"title": "",
						"description": "Integrate the Relay fragment using the `useFragment` hook to read the verification status from the store.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 4,
						"title": "",
						"description": "Ensure the component works correctly with React Suspense for cases where fragment data is not yet available.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 5,
						"title": "",
						"description": "Implement the conditional rendering logic to display the correct view based on the status read from the fragment data.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					}
				]
			},
			{
				"id": 61,
				"title": "Frontend: Define Form Validation Schema with Zod",
				"description": "Define a validation schema for the verification request form using Zod v4 to ensure data integrity before submission.",
				"details": "Create a file `verificationFormSchema.ts`. Using Zod (v3.x is the latest stable, assume this was intended over v4), define an object schema. \n```typescript\nimport { z } from 'zod';\n\nexport const verificationSchema = z.object({\n  organizationName: z.string().min(2, 'Name is required'),\n  contactEmail: z.string().email('Invalid email address'),\n  phoneNumber: z.string().regex(/^(\\+91[\\-\\s]?)?[0]?(91)?[789]\\d{9}$/, 'Must be a valid Indian phone number'),\n  address: z.object({ street: z.string().min(1), city: z.string().min(1), state: z.string().min(1), zip: z.string().min(5) }),\n  businessProofType: z.enum(['type1', 'type2']), // Replace with actual types\n  businessProofURL: z.string().url('A valid file upload is required'),\n  addressProofType: z.enum(['typeA', 'typeB']), // Replace with actual types\n  addressProofURL: z.string().url('A valid file upload is required'),\n});\n```\nThis schema will be used with React Hook Form's `zodResolver`.",
				"testStrategy": "Write unit tests for the schema using Jest or Vitest. Test valid data objects with `.safeParse(data)`. Test various invalid data inputs for each field and assert that the correct error messages are produced.",
				"priority": "high",
				"dependencies": [],
				"status": "done",
				"subtasks": []
			},
			{
				"id": 62,
				"title": "Frontend: Build Static UI for `RequestVerificationForm`",
				"description": "Build the UI for the `RequestVerificationForm` component. The component will be data-driven, consuming a Relay fragment to display initial organization data, and will be built using pre-existing HeroUI components.",
				"status": "done",
				"dependencies": [],
				"priority": "medium",
				"details": "Create the `RequestVerificationForm.tsx` component and define a corresponding Relay fragment (`RequestVerificationForm_organization.graphql`) to specify the organization data it requires. The component must accept a fragment reference as a prop and use the `useFragment` hook to read the data. Use HeroUI components like `<Input>`, `<Select>`, and `<Button>` to build the form structure. Pre-populate fields like Organization Name and Contact Email with data from the fragment. The other fields (Phone Number, Address, Proofs) should be laid out as specified in the PRD. At this stage, focus on rendering the form with initial data. Local form state management and submission logic will be handled in separate tasks.",
				"testStrategy": "Use Storybook to create a story for the form. Mock the Relay environment to provide a fragment reference with sample organization data. Verify that the form fields are correctly pre-populated. Perform visual regression testing to ensure it matches the design. Manually test responsiveness across different viewport sizes (mobile, tablet, desktop).",
				"subtasks": [
					{
						"id": 1,
						"title": "",
						"description": "Define the `RequestVerificationForm_organization.graphql` fragment with necessary fields like `name` and `contactEmail`.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 2,
						"title": "",
						"description": "Update the `RequestVerificationForm` component signature to accept a `fragmentRef` prop.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 3,
						"title": "",
						"description": "Implement the `useFragment` hook within the component to consume the organization data.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 4,
						"title": "",
						"description": "Build the static layout of the form using HeroUI components for all required fields.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 5,
						"title": "",
						"description": "Bind the data from the fragment to pre-populate the corresponding form inputs (e.g., Organization Name, Contact Email).",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 6,
						"title": "",
						"description": "Set up a Storybook story with a mocked Relay environment to test the component with sample fragment data.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					}
				]
			},
			{
				"id": 63,
				"title": "Frontend: Integrate React Hook Form and Zod Validation",
				"description": "Integrate React Hook Form for state management and connect the Zod schema for real-time validation within the `RequestVerificationForm`.",
				"details": "In `RequestVerificationForm.tsx`, import and use the `useForm` hook from `react-hook-form` and `zodResolver` from `@hookform/resolvers/zod`. \n```typescript\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { verificationSchema } from './verificationFormSchema';\n\nconst form = useForm({ resolver: zodResolver(verificationSchema) });\n```\nUse `form.register('fieldName')` to connect each HeroUI input. Use `form.formState.errors` to display validation messages next to each field. Implement the form's `onSubmit` handler using `form.handleSubmit(yourSubmitFunction)`.",
				"testStrategy": "Using React Testing Library, simulate user input into the form fields. Assert that valid input does not show an error message, and invalid input does. Test that submitting the form with invalid data does not call the submit handler and displays all relevant errors.",
				"priority": "high",
				"dependencies": [61, 62],
				"status": "done",
				"subtasks": []
			},
			{
				"id": 64,
				"title": "Frontend: Handle File Selection and Fetch Presigned URL",
				"description": "Implement the client-side logic to handle file selection and call the `createOrganizationProofPresignedUrl` Relay GraphQL mutation to get a secure upload URL from S3.",
				"status": "done",
				"dependencies": [62],
				"priority": "medium",
				"details": "Create a reusable file upload component or hook. When a user selects a file in one of the file input fields, trigger a call to the `createOrganizationProofPresignedUrl` GraphQL mutation using Relay's `useMutation` hook. Pass the file's name and type to the mutation. The component should manage the loading state while waiting for the presigned URL. The returned URL and the final object key should be stored in the component's state.",
				"testStrategy": "Mock the Relay environment and the `createOrganizationProofPresignedUrl` mutation response. In a unit test, simulate a file being selected and verify that the mutation is called with the correct variables. Test the component's behavior during the loading and error states of the mutation.",
				"subtasks": [
					{
						"id": 1,
						"title": "",
						"description": "Define the `createOrganizationProofPresignedUrl` mutation using Relay's `graphql` tag and run the compiler.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 2,
						"title": "",
						"description": "Create a reusable file upload hook or component that uses Relay's `useMutation` hook to execute the presigned URL mutation.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 3,
						"title": "",
						"description": "Implement state management within the hook/component for loading, error, and success states, storing the returned URL and object key.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 4,
						"title": "",
						"description": "Write unit tests using a mocked Relay environment to verify the mutation is called correctly and the component handles different states.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					}
				]
			},
			{
				"id": 65,
				"title": "Frontend: Implement File Upload to S3 Presigned URL",
				"description": "Implement the function to upload the selected file directly to the S3 presigned URL, including progress and error handling.",
				"details": "Once the presigned URL is obtained (from task 64), use the `fetch` API or a library like `axios` to perform an HTTP `PUT` request to that URL. The request body should be the file object itself. The `Content-Type` header must be set to the file's type. Implement UI feedback for the upload status: progress (using `XMLHttpRequest.upload.onprogress`), success, and failure. On successful upload, update the React Hook Form state with the final file URL/key using `form.setValue('businessProofURL', finalUrl)`.",
				"testStrategy": "Use a library like `msw` (Mock Service Worker) to intercept the `PUT` request to the S3 URL. Verify the request has the correct method, headers, and body. Simulate success and failure responses from the mock server to test the component's error handling and state updates.",
				"priority": "medium",
				"dependencies": [64],
				"status": "done",
				"subtasks": []
			},
			{
				"id": 66,
				"title": "Frontend: Implement Form Submission Mutation",
				"description": "Implement the final form submission logic, which calls the `requestOrganizationVerification` mutation using Relay with all validated form data and uploaded file URLs.",
				"status": "done",
				"dependencies": [63, 65],
				"priority": "high",
				"details": "The `onSubmit` function passed to `form.handleSubmit` will be the entry point. This function receives the validated form data. It should verify that the file URLs have been set by the upload process. Then, it will execute the `requestOrganizationVerification` GraphQL mutation using Relay's `useMutation` hook, passing all form fields as variables. Implement loading and error handling for this mutation, providing user feedback via toasts or inline messages. On success, update the Relay store to reflect the organization's new 'pending' status, which will update the UI.",
				"testStrategy": "Mock the Relay environment and the `requestOrganizationVerification` mutation response. Using React Testing Library, fill out the form with valid data, simulate successful file uploads, and submit the form. Verify that the mutation is called with the complete and correct payload. Test the component's behavior when the mutation returns an error. Assert that the Relay store is updated correctly on a successful response.",
				"subtasks": [
					{
						"id": 1,
						"title": "",
						"description": "Define the `requestOrganizationVerificationMutation.graphql` file and run the Relay compiler to generate the necessary artifacts.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 2,
						"title": "",
						"description": "Integrate the `useMutation` hook from `react-relay` into the form component for the `requestOrganizationVerification` mutation.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 3,
						"title": "",
						"description": "Wire the form's `onSubmit` handler to call the Relay mutation with the validated form data and file URLs.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 4,
						"title": "",
						"description": "Implement UI feedback for loading (e.g., disabling submit button) and error states (e.g., showing a toast message) of the mutation.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 5,
						"title": "",
						"description": "On successful mutation, implement an updater function to modify the Relay store, changing the organization's verification status to 'pending' to trigger the correct UI view.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					}
				]
			},
			{
				"id": 67,
				"title": "Frontend: Implement 'Pending' Status View",
				"description": "Create the UI component to display the 'pending' verification status, using data fetched via a Relay fragment.",
				"status": "done",
				"dependencies": [60],
				"priority": "medium",
				"details": "Create a React component named `PendingVerificationView` that is driven by a Relay fragment. The component will accept a fragment reference to the organization's data as a prop. Use the `useFragment` hook to read the necessary data. It should display a clear message, such as 'Your verification request has been submitted and is currently under review. We will notify you once the process is complete.' Use HeroUI components for styling to maintain visual consistency.",
				"testStrategy": "Render the component in Storybook using a mocked Relay environment. Pass a mocked fragment reference and verify its appearance and text content. Write a unit test using React Testing Library and a mocked Relay environment to ensure the component correctly consumes the fragment data. Ensure it is responsive and visually consistent with the rest of the application.",
				"subtasks": [
					{
						"id": 1,
						"title": "",
						"description": "Define the GraphQL fragment for `PendingVerificationView` to specify its data requirements from the `Organization` type.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 2,
						"title": "",
						"description": "Implement the `PendingVerificationView` component to accept a fragment reference and use the `useFragment` hook to consume data.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 3,
						"title": "",
						"description": "Style the component using HeroUI to display the pending status message, ensuring visual consistency.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 4,
						"title": "",
						"description": "Set up Storybook for the component with a mocked Relay environment to test its visual states.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 5,
						"title": "",
						"description": "Write unit tests with React Testing Library and a mocked Relay environment to verify the component correctly renders based on fragment data.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					}
				]
			},
			{
				"id": 68,
				"title": "Frontend: Implement 'Rejected' Status View with Retry",
				"description": "Create the UI component for the 'rejected' status, which includes a rejection message and a button to restart the application process. This component will be driven by a Relay fragment to display relevant data about the rejection.",
				"status": "done",
				"dependencies": [60, 62],
				"priority": "medium",
				"details": "Create a React component named `RejectedVerificationView` that is driven by a Relay fragment. The component will accept a fragment reference to the organization's data as a prop and use the `useFragment` hook to read the necessary data (e.g., rejection reason). It should display a message like 'Your verification request was rejected. Please review the requirements and try again.' and include the specific reason if available. It must also include a 'Try Again' button. This button will call an `onRetry` function prop, which will signal the parent controller to re-render the `RequestVerificationForm`.",
				"testStrategy": "Render the component in Storybook using a mocked Relay environment. Pass a mocked fragment reference and verify its appearance and text content, including the rejection reason. Use `@storybook/addon-actions` to verify the `onRetry` function is called when the 'Try Again' button is clicked. Write a unit test using React Testing Library and a mocked Relay environment to ensure the component correctly consumes the fragment data and that the retry logic is triggered.",
				"subtasks": [
					{
						"id": 1,
						"title": "",
						"description": "Define the GraphQL fragment for RejectedVerificationView, specifying the fields needed from the Organization type (e.g., rejectionReason).",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 2,
						"title": "",
						"description": "Implement the RejectedVerificationView React component, using the useFragment hook to consume the organization data from the fragment reference prop.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 3,
						"title": "",
						"description": "Display the rejection message and reason within the component. Implement the 'Try Again' button and connect its onClick event to the onRetry prop.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 4,
						"title": "",
						"description": "Create Storybook stories for the component, providing a mocked Relay environment and sample fragment data to test different rejection scenarios.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					},
					{
						"id": 5,
						"title": "",
						"description": "Write unit tests with React Testing Library and a mocked Relay environment to verify correct data rendering and that the onRetry callback is invoked on button click.",
						"status": "done",
						"dependencies": [],
						"details": "",
						"testStrategy": ""
					}
				]
			},
			{
				"id": 69,
				"title": "Frontend: Implement Conditional UI Rendering Logic",
				"description": "Finalize the main controller component to correctly render the UI based on the fetched `verificationStatus`.",
				"details": "In the `OrganizationVerificationStatusController` component, complete the conditional rendering logic. Use the `verificationStatus` string from the GraphQL query to decide which component to display: 'verified' -> `<AlreadyVerified />`, 'pending' -> `<PendingVerificationView />`, 'rejected' -> `<RejectedVerificationView onRetry={...} />`, 'not_requested' -> `<RequestVerificationForm />`. Ensure smooth transitions and proper state management for retrying a rejected application.",
				"testStrategy": "This is a key integration test. Using React Testing Library, mock the GraphQL query and cycle through all possible status values. For each value, assert that the correct child component is rendered. Test the 'rejected' flow by verifying that clicking the retry button renders the form.",
				"priority": "high",
				"dependencies": [60, 66, 67, 68],
				"status": "done",
				"subtasks": []
			},
			{
				"id": 70,
				"title": "Final Polish: Accessibility, Responsiveness, and UX Review",
				"description": "Perform a comprehensive review of the entire feature to ensure accessibility compliance, mobile responsiveness, and a polished user experience.",
				"details": "Review all new components. Add appropriate ARIA attributes to form fields (`aria-describedby` for errors, `aria-required`). Ensure all interactive elements are keyboard-focusable and operable. Test the entire flow with a screen reader (e.g., VoiceOver, NVDA). Add loading indicators (spinners) for all async operations (data fetching, file uploading, form submission). Verify the layout is fluid and usable on mobile screen sizes. Refine all user-facing text for clarity.",
				"testStrategy": "Manual end-to-end testing on desktop and mobile browsers. Use automated accessibility checking tools like Axe DevTools. Perform manual keyboard-only navigation tests. Conduct a user acceptance testing (UAT) session to gather feedback on the overall workflow and user experience.",
				"priority": "low",
				"dependencies": [69],
				"status": "done",
				"subtasks": []
			}
		],
		"metadata": {
			"created": "2025-06-26T11:00:37.508Z",
			"updated": "2025-08-01T16:40:06.328Z",
			"description": "Tasks for master context"
		}
	}
}
